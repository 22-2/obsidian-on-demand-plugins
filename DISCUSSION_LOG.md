# Lazy with View 機能実装に関する検討ログ

## 現状の課題と提案
- **目的**: `setViewState` で View がセットされた際、対応するプラグインを自動でロードする仕組みを作りたい。
- **挫折点**: 以前の試みでは、ロード/アンロードの制御が複雑化しすぎて失敗。特に自動検出（全プラグインのView登録状況をスキャン）が鬼門だった。
- **新提案**: 
    - 自動検出を諦め、**PluginModes** に新たに `LazyWithView` を追加。
    - ユーザーが手動で `PluginID -> ViewType[]` を設定する「手動マッピング方式」を採用。
    - これにより、複雑なスキャン処理や副作用を回避し、シンプルに実装する。

## 実装計画と方針（PLAN.md より）
1. **設定**: `PluginModes` に `LazyWithView` を追加。
2. **マッピング**: `settings` に `lazyWithView: Record<pluginId, string[]>` を追加（手動設定）。
3. **ロジック**: `setViewState` のフックで、開かれた ViewType が上記設定に存在すれば、対応プラグインをロード。
4. **シンプル維持**: 
    - アンロードは自動化しない（状態管理が複雑化するため）。
    - ロード完了の厳密な判定は行わず、冪等性を担保して必要時にロードリクエストを出すだけにする。
    - 「全プラグイン一括有効化→再起動」案は今回は見送る（Obsidianの仕様上、リスクと手間が見合わないため）。

## Apply Changes 機能との切り分け
- Apply Changes における「全プラグインの一時ロード＆アンロード（スキャン）」による大量のエラーや副作用の問題については、今回の Lazy with View 実装とは切り離して考える。
- 本実装（手動マッピング）は、そもそも Apply Changes のスキャン結果に依存しないため、スキャン機能が不安定でも影響を受けない。

## Apply Changes の改善に向けた検討案 (将来課題)
- **現状**: `StartupPolicyService.apply` で一つずつ「ロード -> 読み込み待機 -> アンロード」を繰り返しているが、アンロードが早すぎるためかコンソールエラーが多発し、不安定。
- **提案**: 「一括ロード -> 完了待機 -> リセット -> 再起動」方式
    1. `p-queue` 等を用いて全てのプラグインを（並列または高速に）ロード。
    2. 全プラグインの `_loaded` が有効になり、さらに数秒の待機を入れてコマンドやビューの登録が完全に終わるのを待つ。
    3. `community-plugins.json` に `KeepEnabled` リストだけを上書き（`pluginmanager.js` の仕様上、`enablePluginAndSave` 等を呼ばなければ勝手に更新はされない）。
    4. Obsidian を再起動。
- **期待される効果**: アンロードによる副作用によるエラーを防ぎつつ、全てのプラグインの情報を確実にキャッシュできる。
